var fooformsApp = angular.module('fooformsApp', [
    'ngRoute', 'restangular', 'ui.bootstrap', 'textAngular', 'ui.calendar'
]);

// configure our routes
fooformsApp.config(function ($routeProvider, $locationProvider) {
    'use strict';
    $locationProvider.html5Mode(true).hashPrefix('!');

    $routeProvider
        .when('/', {
            redirectTo: '/dashboard'
        })
        .when('/dashboard', {
            templateUrl: '/partials/dashboard',
            controller: 'DashboardCtrl'
        })
        .when('/clouds', {
            templateUrl: '/partials/clouds',
            controller: 'CloudCtrl'
        })
        .when('/apps', {
            templateUrl: '/partials/apps',
            controller: 'AppsCtrl'
        })
        .when('/people', {
            templateUrl: '/partials/people'
        })
        .when('/calendar', {
            templateUrl: '/partials/calendar'
        })
        .when('/profile', {
            templateUrl: '/partials/profile',
            controller: 'ProfileCtrl'
        })
        .when('/userGuide', {
            templateUrl: '/partials/userGuide'
        })
        .when('/settings', {
            templateUrl: '/partials/settings'
        })
        .when('/admin', {
            templateUrl: '/partials/admin'
        })
        .when('/appBuilder', {
            templateUrl: '/partials/appBuilder',
            controller: 'fieldsCtrl'
        })
        .otherwise({
            redirectTo: '/404'
        });
});
;
;
fooformsApp.controller('AppsCtrl', ['$scope', 'Restangular', 'appService',
    function ($scope, Restangular, appService) {
        'use strict';
        Restangular.setBaseUrl('/api');
        Restangular.setDefaultHeaders({'Content-Type': 'application/json'});
        var appApi = Restangular.all('apps');

        var updateAppList = function () {
            appApi.getList().then(function (apps) {
                $scope.apps = apps;
            });
        };

        // Get all the existing apps and save them in the scope
        updateAppList();

        $scope.hover = function (app) {
            // Shows/hides the delete button on hover
            return app.showOptions = !app.showOptions;
        };

        $scope.viewApp = function (app) {

        };

        $scope.newApp = function () {
            appService.resetApp();
        }

        $scope.updateApp = function (app) {
            appService.setApp(app);

        };

        $scope.deleteApp = function (app) {
            app.remove().then(function (res) {
                // TODO: Do I need ot check the response for anything
                var index = $scope.apps.indexOf(app);

                if (index > -1) {
                    $scope.apps.splice(index, 1);
                }
            }, function (err) {
                // This only gets called if there's an error response
                console.log(err.status);
                $("#thumb-" + app._id).effect("shake");
            });
        };

    }]);

;
fooformsApp.service('appService', function () {
    'use strict';
    this.app = {};

    this.resetApp = function () {
        this.app = {};
    };

    this.setApp = function (newApp) {
        this.app = newApp;
    };
    this.getApp = function () {
        if (_.isEmpty(this.app)) {
            this.app = {
                "name": "Untitled App",
                "icon": "/assets/icons/color/document.png",
                "description": "My new app - it's totally awesome!",
                "menuLabel": "Untitled App",
                "btnLabel": "New Post",
                "settings": {
                    "allowComments": true,
                    "status": "draft",
                    "displayOptions": [
                        {
                            "feed": true,
                            "grid": true,
                            "card": true
                        }
                    ]
                },
                "fields": [],
                "version": 1,
                "created": new Date(),
                "lastModified": new Date(),
                "owner": ""
            };
        }
        return this.app;
    };
});
;
/**
 * Created by mcaulb1 on 1/17/14.
 */

// Declare app level module which depends on filters, and services
angular.module('appBuilder', [
    'appBuilder.filters',
    'appBuilder.services',
    'appBuilder.directives',
    'appBuilder.controllers',
    'ui.bootstrap'
]);
/* Controllers */

fooformsApp.controller('fieldsCtrl', ['$scope', '$http', 'DragDropHandler' , '$modal', 'Restangular', 'appService', function ($scope, $http, DragDropHandler, $modal, Restangular, appService) {
    "use strict";
    Restangular.setBaseUrl('/api');
    Restangular.setDefaultHeaders({'Content-Type': 'application/json'});
    var appApi = Restangular.all('apps');


    $http.get('/js/appBuilder/inputTypes.json').success(function (data) {

        $scope.inputTypes = data.inputTypes;
        $scope.icons = data.icons;

    });
    // the main object to store the app data
    $scope.app = appService.getApp();
    // some booleans to help track what we are editing, which tabs to enable, etc.
    // used in ng-show in appBuilderMenu
    $scope.nowEditing = null;
    $scope.nowSubEditing = null;
    $scope.showFieldSettings = false;
    $scope.showGroupSettings = false;
    $scope.showAppSettings = false;
    $scope.dragging = false;

    //following are all called from the directives droppable or subdroppable

    $scope.updateObjects = function (from, to) {
        var itemIds = _.pluck($scope.app.fields, 'id');
        console.log(itemIds);
        $scope.dragging = false;
    };

    $scope.createObject = function (object, to) {
        var newItem = angular.copy(object);
        newItem.id = Math.ceil(Math.random() * 1000);
        DragDropHandler.addObject(newItem, $scope.app.fields, to);
        $scope.dragging = false;
    };
    $scope.deleteItem = function (itemId) {
        $scope.app.fields = _.reject($scope.app.fields, function (field) {
            return field.id == itemId;
        });
    }
    $scope.createSubObject = function (object, repeatBox, to) {
        var newItem = angular.copy(object);
        newItem.id = Math.ceil(Math.random() * 1000);
        DragDropHandler.addObject(newItem, $scope.app.fields[repeatBox].fields, to);
        $scope.dragging = false;
    };

    $scope.updateSubObjects = function (repeatBox, from, to) {
        var itemIds = _.pluck($scope.app.fields, 'id');
        console.log(itemIds);
        $scope.dragging = false;
    };
    $scope.deleteSubItem = function (itemId) {
        $scope.app.fields[$scope.nowEditing].fields = _.reject($scope.app.fields[$scope.nowEditing].fields, function (field) {
            return field.id == itemId;
        });
    }
// Used to add options to selects, radios, i.e. Single selection
    $scope.addOption = function ($index) {
        if ($scope.nowSubEditing == null) {
            $scope.app.fields[$scope.nowEditing].options.splice($index + 1, 0, {"label": ""});
        } else {
            $scope.app.fields[$scope.nowEditing].fields[$scope.nowSubEditing].options.splice($index + 1, 0, {"label": ""});
        }
    }
// Used to add options to checkboxes i.e. Multiple selection
    $scope.addOptionObject = function ($index) {
        if ($scope.nowSubEditing == null) {
            $scope.app.fields[$scope.nowEditing].options.splice($index + 1, 0, {"label": "", "selected": false});
        } else {
            $scope.app.fields[$scope.nowEditing].fields[$scope.nowSubEditing].options.splice($index + 1, 0, {"label": "", "selected": false});
        }
    }

// removes options from selects, radios, etc....
    $scope.deleteOption = function ($index) {
        if ($scope.nowSubEditing == null) {
            $scope.app.fields[$scope.nowEditing].options.splice($index, 1);
        } else {
            $scope.app.fields[$scope.nowEditing].fields[$scope.nowSubEditing].options.splice($index, 1);
        }
    };

    // dragging has started -  null nowEditing and show borders on all formfields to aid with dropping.
    $scope.showBorders = function (show) {
        $scope.dragging = show;
        $scope.nowEditing = null;
        $scope.nowSubEditing = null;
        $scope.$apply();
    }

    // should we show the default placeholder - i.e. - there are no formfields
    $scope.showPlaceHolder = function (container) {
        return container.length == 0
    }

    // switch on/off the various option panels and track / highlight the selected form-fields
    $scope.editField = function (fieldId, subFieldId, objectType, $event) {
        switch (objectType) {
            case 'Application':
                $scope.nowEditing = null;
                $scope.nowSubEditing = null;
                $scope.showFieldSettings = false;
                $scope.showGroupSettings = false;
                $scope.showAppSettings = true;
                break;
            case 'Field' :
                $scope.nowEditing = fieldId;
                $scope.nowSubEditing = subFieldId; //null
                $scope.showFieldSettings = true;
                $scope.showGroupSettings = false;
                $scope.showAppSettings = false;
                break;
            case 'Group' :
                $scope.nowEditing = fieldId;
                $scope.nowSubEditing = subFieldId;
                $scope.showFieldSettings = false;
                $scope.showGroupSettings = true;
                $scope.showAppSettings = false;
                break;
            default :
                $scope.nowEditing = null;
                $scope.nowSubEditing = null;
                $scope.showFieldSettings = false;
                $scope.showGroupSettings = false;
                $scope.showAppSettings = false;
                break;

        }
        $event.stopPropagation();
        angular.element('#appTabSettings').tab('show')


    }

    // Set Calculation Field Options
    $scope.setCalculationField = function (selectedItem) {

        if ($scope.nowSubEditing == null) {
            $scope.app.fields[$scope.nowEditing].options.field1.item = selectedItem;
        } else {
            $scope.app.fields[$scope.nowEditing].options.field1.item = "value";
        }
    }


//Icon Selection -  Modal Dialog
    $scope.open = function () {

        var modalInstance = $modal.open({
            templateUrl: '/partials/icons.html',
            controller: ModalInstanceCtrl,
            resolve: {
                icons: function () {
                    return $scope.icons;
                }
            }
        });

        modalInstance.result.then(function (selectedItem) {
            $scope.app.icon = selectedItem;
        });
    };

// End Icon Selection -  Modal Dialog

    $scope.saveApp = function (appToSave) {
        console.log(JSON.stringify(appToSave));
        if (appToSave._id) {
            // App already exists on server
            appToSave.put().then(function (res) {
                console.log('update');
            }, function (err) {
                console.log(err.status);
            });
        } else {
            appApi.post(appToSave).then(function (res) {
                console.log(JSON.stringify(res));
                $scope.app = res;
            }, function (err) {
                console.log(err.status);
            });
        }
    };

    $scope.newApp = function (previousApp) {
        // TODO: Check if there are unsaved changes and warn

        appService.resetApp();
        $scope.app = appService.getApp();

        // Why isn't that working aaaarrghhh!!!
    }

}])
;

var ModalInstanceCtrl = function ($scope, $modalInstance, icons) {
    'use strict';

    $scope.icons = icons;
    $scope.chosen = {
        icon: $scope.icons[0]
    };

    $scope.ok = function () {
        $modalInstance.close($scope.chosen.icon);
    };

    $scope.cancel = function () {
        $modalInstance.dismiss('cancel');
    };

};
;
/* Directives */

fooformsApp.factory('DragDropHandler', [function () {
    'use strict';
    return {
        dragObject: undefined,
        addObject: function (object, objects, to) {
            objects.splice(to, 0, object);
        },
        moveObject: function (objects, from, to) {
            objects.splice(to, 0, objects.splice(from, 1)[0]);
        }
    };
}])

    .directive('draggable', ['DragDropHandler', function (DragDropHandler) {
        return {
            scope: {
                draggable: '=',
                ngBorder: '&'
            },
            link: function (scope, element, attrs) {
                element.draggable({
                    connectToSortable: attrs.draggableTarget,
                    helper: "clone",
                    revert: "invalid",
                    start: function () {
                        DragDropHandler.dragObject = scope.draggable;
                        scope.ngBorder({'show': true});

                    },
                    stop: function () {
                        DragDropHandler.dragObject = undefined;
                        scope.ngBorder({'show': false});
                        scope.$parent.$apply();
                    }
                });

                element.disableSelection();
            }
        };
    }])

    .directive('droppable', ['DragDropHandler', function (DragDropHandler) {
        return {
            scope: {
                droppable: '=',
                ngUpdate: '&',
                ngCreate: '&',
                ngBorder: '&'

            },
            link: function (scope, element, attrs) {
                element.sortable();
                element.disableSelection();
                element.on("sortstart", function (event, ui) {

                    scope.$parent.showBorders(true);

                });
                element.on("sortdeactivate", function (event, ui) {
                    try {
                        var from = angular.element(ui.item).scope().$index;
                        scope.$parent.nowEditing = from;
                        var to = element.children().index(ui.item);

                        if (to >= 0) {
                            scope.$apply(function () {
                                if (from >= 0) {
                                    DragDropHandler.moveObject(scope.droppable, from, to);
                                    scope.ngUpdate({
                                        from: from,
                                        to: to
                                    });

                                } else {
                                    scope.ngCreate({
                                        object: DragDropHandler.dragObject,
                                        to: to
                                    });
                                    ui.item.remove();

                                }
                            });

                        }
                    } catch (e) {
                        alert(e);
                    }
                    scope.$parent.$apply();
                });

            }
        };
    }])

// not used but may be useful some day......

    .directive('compile', function ($compile) {
        // directive factory creates a link function
        return function (scope, element, attrs) {
            scope.$watch(
                function (scope) {
                    // watch the 'compile' expression for changes
                    return scope.$eval(attrs.compile);
                },
                function (value) {
                    // when the 'compile' expression changes
                    // assign it into the current DOM
                    element.html(value);

                    // compile the new DOM and link it to the current
                    // scope.
                    // NOTE: we only compile .childNodes so that
                    // we don't get into infinite loop compiling ourselves
                    $compile(element.contents())(scope);
                }
            );
        };
    })


    .directive('subdroppable', ['DragDropHandler', function (DragDropHandler) {
        return {
            scope: {
                subdroppable: '=',
                ngUpdate: '&',
                ngCreate: '&',
                ngBorder: '&'

            },
            link: function (scope, element, attrs) {

                element.sortable();
                element.disableSelection();
                element.on("sortstart", function (event, ui) {

                    scope.$parent.showBorders(true);

                });
                element.on("sortdeactivate", function (event, ui) {
                    var repeatBox = angular.element(ui.item).scope().$index;
                    var from = angular.element(ui.item).scope().$index;
                    var to = element.children().index(ui.item);

                    scope.$parent.nowEditing = from;
                    scope.$parent.nowSubEditing = repeatBox;

                    if (to >= 0) {
                        scope.$apply(function () {
                            if (angular.element(ui.item).scope().subField !== undefined) {
                                DragDropHandler.moveObject(scope.subdroppable, from, to);
                                scope.ngUpdate({
                                    from: from,
                                    to: to
                                });

                            } else {
                                scope.ngCreate({
                                    object: DragDropHandler.dragObject,
                                    repeatbox: repeatBox,
                                    to: to
                                });

                                ui.item.remove();
                            }
                        });
                    }
                    event.stopPropagation();
                    scope.$parent.$apply();
                });
            }
        };
    }])
;
/* Filters */

// Filter app fields based on category
fooformsApp.filter('filterTypes', function () {
    'use strict';
    return function (inputs, category) {
        var standard = ["text", "textarea", "email", "select", "checkbox", "radio", "paragraph", "date", "groupbox"];
        var numbers = ["number", "calculation", "currency", "sum", "payment", "progress"];
        var people = ["to", "user" , "signature", "profile", "activity"];
        var advanced = ["status", "labels", "html", "groupBox", "rating", "canvas", "button"];

        // The filter array to be assigned based on the category
        var categoryFilter;

        var filtered = [];
        try {
            switch (category) {
                case "standard" :
                    categoryFilter = standard;
                    break;
                case "number" :
                    categoryFilter = numbers;
                    break;
                case "people" :
                    categoryFilter = people;
                    break;
                case "advanced" :
                    categoryFilter = advanced;
                    break;
                default :
                    return inputs; // If no category, might as well not filter
                    break;
            }

            if (categoryFilter) {
                angular.forEach(inputs, function (input) {
                    // Check if input type exists in categoryFilter array
                    if (categoryFilter.indexOf(input.type) > -1) {
                        filtered.push(input);
                    }
                });
            }
        } catch (err) {
            // TODO: What to do if some error? Maybe just return all inputs?
            console.err(err.toString());
        }
        return filtered;
    }

});


;
/* Services */


fooformsApp.service('CalculatorService', function (MathService) {
    'use strict';
    this.square = function (a) {
        return MathService.multiply(a, a);
    };
    this.cube = function (a) {
        return MathService.multiply(a, MathService.multiply(a, a));
    };

});
;
/*
 *  AngularJs Fullcalendar Wrapper for the JQuery FullCalendar
 *  API @ http://arshaw.com/fullcalendar/
 *
 *  Angular Calendar Directive that takes in the [eventSources] nested array object as the ng-model and watches it deeply changes.
 *       Can also take in multiple event urls as a source object(s) and feed the events per view.
 *       The calendar will watch any eventSource array and update itself when a change is made.
 *
 */

angular.module('ui.calendar', [])
    .constant('uiCalendarConfig', {})
    .controller('uiCalendarCtrl', ['$scope', '$timeout', function ($scope, $timeout) {

        var sourceSerialId = 1,
            eventSerialId = 1,
            sources = $scope.eventSources,
            extraEventSignature = $scope.calendarWatchEvent ? $scope.calendarWatchEvent : angular.noop,

            wrapFunctionWithScopeApply = function (functionToWrap) {
                var wrapper;

                if (functionToWrap) {
                    wrapper = function () {
                        // This happens outside of angular context so we need to wrap it in a timeout which has an implied apply.
                        // In this way the function will be safely executed on the next digest.

                        var args = arguments;
                        $timeout(function () {
                            functionToWrap.apply(this, args);
                        });
                    };
                }

                return wrapper;
            };

        this.eventsFingerprint = function (e) {
            if (!e.__uiCalId) {
                e.__uiCalId = eventSerialId++;
            }
            // This extracts all the information we need from the event. http://jsperf.com/angular-calendar-events-fingerprint/3
            return "" + e.__uiCalId + (e.id || '') + (e.title || '') + (e.url || '') + (+e.start || '') + (+e.end || '') +
                (e.allDay || '') + (e.className || '') + extraEventSignature(e) || '';
        };

        this.sourcesFingerprint = function (source) {
            return source.__id || (source.__id = sourceSerialId++);
        };

        this.allEvents = function () {
            // return sources.flatten(); but we don't have flatten
            var arraySources = [];
            for (var i = 0, srcLen = sources.length; i < srcLen; i++) {
                var source = sources[i];
                if (angular.isArray(source)) {
                    // event source as array
                    arraySources.push(source);
                } else if (angular.isObject(source) && angular.isArray(source.events)) {
                    // event source as object, ie extended form
                    var extEvent = {};
                    for (var key in source) {
                        if (key !== '_uiCalId' && key !== 'events') {
                            extEvent[key] = source[key];
                        }
                    }
                    for (var eI = 0; eI < source.events.length; eI++) {
                        angular.extend(source.events[eI], extEvent);
                    }
                    arraySources.push(source.events);
                }
            }

            return Array.prototype.concat.apply([], arraySources);
        };

        // Track changes in array by assigning id tokens to each element and watching the scope for changes in those tokens
        // arguments:
        //  arraySource array of function that returns array of objects to watch
        //  tokenFn function(object) that returns the token for a given object
        this.changeWatcher = function (arraySource, tokenFn) {
            var self;
            var getTokens = function () {
                var array = angular.isFunction(arraySource) ? arraySource() : arraySource;
                var result = [], token, el;
                for (var i = 0, n = array.length; i < n; i++) {
                    el = array[i];
                    token = tokenFn(el);
                    map[token] = el;
                    result.push(token);
                }
                return result;
            };
            // returns elements in that are in a but not in b
            // subtractAsSets([4, 5, 6], [4, 5, 7]) => [6]
            var subtractAsSets = function (a, b) {
                var result = [], inB = {}, i, n;
                for (i = 0, n = b.length; i < n; i++) {
                    inB[b[i]] = true;
                }
                for (i = 0, n = a.length; i < n; i++) {
                    if (!inB[a[i]]) {
                        result.push(a[i]);
                    }
                }
                return result;
            };

            // Map objects to tokens and vice-versa
            var map = {};

            var applyChanges = function (newTokens, oldTokens) {
                var i, n, el, token;
                var replacedTokens = {};
                var removedTokens = subtractAsSets(oldTokens, newTokens);
                for (i = 0, n = removedTokens.length; i < n; i++) {
                    var removedToken = removedTokens[i];
                    el = map[removedToken];
                    delete map[removedToken];
                    var newToken = tokenFn(el);
                    // if the element wasn't removed but simply got a new token, its old token will be different from the current one
                    if (newToken === removedToken) {
                        self.onRemoved(el);
                    } else {
                        replacedTokens[newToken] = removedToken;
                        self.onChanged(el);
                    }
                }

                var addedTokens = subtractAsSets(newTokens, oldTokens);
                for (i = 0, n = addedTokens.length; i < n; i++) {
                    token = addedTokens[i];
                    el = map[token];
                    if (!replacedTokens[token]) {
                        self.onAdded(el);
                    }
                }
            };
            return self = {
                subscribe: function (scope, onChanged) {
                    scope.$watch(getTokens, function (newTokens, oldTokens) {
                        if (!onChanged || onChanged(newTokens, oldTokens) !== false) {
                            applyChanges(newTokens, oldTokens);
                        }
                    }, true);
                },
                onAdded: angular.noop,
                onChanged: angular.noop,
                onRemoved: angular.noop
            };
        };

        this.getFullCalendarConfig = function (calendarSettings, uiCalendarConfig) {
            var config = {};

            angular.extend(config, uiCalendarConfig);
            angular.extend(config, calendarSettings);

            angular.forEach(config, function (value, key) {
                if (typeof value === 'function') {
                    config[key] = wrapFunctionWithScopeApply(config[key]);
                }
            });

            return config;
        };
    }])
    .directive('uiCalendar', ['uiCalendarConfig', '$locale', function (uiCalendarConfig, $locale) {
        // Configure to use locale names by default
        var tValues = function (data) {
            // convert {0: "Jan", 1: "Feb", ...} to ["Jan", "Feb", ...]
            var r, k;
            r = [];
            for (k in data) {
                r[k] = data[k];
            }
            return r;
        };
        var dtf = $locale.DATETIME_FORMATS;
        uiCalendarConfig = angular.extend({
            monthNames: tValues(dtf.MONTH),
            monthNamesShort: tValues(dtf.SHORTMONTH),
            dayNames: tValues(dtf.DAY),
            dayNamesShort: tValues(dtf.SHORTDAY)
        }, uiCalendarConfig || {});

        return {
            restrict: 'A',
            scope: {eventSources: '=ngModel', calendarWatchEvent: '&'},
            controller: 'uiCalendarCtrl',
            link: function (scope, elm, attrs, controller) {

                var sources = scope.eventSources,
                    sourcesChanged = false,
                    eventSourcesWatcher = controller.changeWatcher(sources, controller.sourcesFingerprint),
                    eventsWatcher = controller.changeWatcher(controller.allEvents, controller.eventsFingerprint),
                    options = null;

                function getOptions() {
                    var calendarSettings = attrs.uiCalendar ? scope.$parent.$eval(attrs.uiCalendar) : {},
                        fullCalendarConfig;

                    fullCalendarConfig = controller.getFullCalendarConfig(calendarSettings, uiCalendarConfig);

                    options = { eventSources: sources };
                    angular.extend(options, fullCalendarConfig);

                    var options2 = {};
                    for (var o in options) {
                        if (o !== 'eventSources') {
                            options2[o] = options[o];
                        }
                    }
                    return JSON.stringify(options2);
                }

                scope.destroy = function () {
                    if (attrs.calendar) {
                        scope.calendar = scope.$parent[attrs.calendar] = elm.html('');
                    } else {
                        scope.calendar = elm.html('');
                    }
                };

                scope.init = function () {
                    scope.calendar.fullCalendar(options);
                };

                eventSourcesWatcher.onAdded = function (source) {
                    scope.calendar.fullCalendar('addEventSource', source);
                    sourcesChanged = true;
                };

                eventSourcesWatcher.onRemoved = function (source) {
                    scope.calendar.fullCalendar('removeEventSource', source);
                    sourcesChanged = true;
                };

                eventsWatcher.onAdded = function (event) {
                    scope.calendar.fullCalendar('renderEvent', event);
                };

                eventsWatcher.onRemoved = function (event) {
                    scope.calendar.fullCalendar('removeEvents', function (e) {
                        return e === event;
                    });
                };

                eventsWatcher.onChanged = function (event) {
                    scope.calendar.fullCalendar('updateEvent', event);
                };

                scope.destroy();
                getOptions();
                scope.init();
                eventSourcesWatcher.subscribe(scope);
                eventsWatcher.subscribe(scope, function (newTokens, oldTokens) {
                    if (sourcesChanged === true) {
                        sourcesChanged = false;
                        // prevent incremental updates in this case
                        return false;
                    }
                });

                scope.$watch(getOptions, function (newO, oldO) {
                    if (newO !== oldO) {
                        scope.destroy();
                        scope.init();
                    }
                });
            }
        };
    }]);
;
fooformsApp.controller('CloudCtrl', function ($scope, $route, Restangular) {
    "use strict";
    Restangular.setBaseUrl('/api');
    Restangular.setDefaultHeaders({'Content-Type': 'application/json'});

    var cloudApi = Restangular.all('clouds');

    /**
     * Gets the clouds owned by this user
     *
     * TODO: Using updateCloudList all over the place for now. Can make this a lot more efficient by using the server response.
     */

    $scope.tabs = [
        {name: "Clouds", active: true},
        {name: "Settings", active: false}
    ];
    $scope.nowEditing = 0;
    $scope.showBorders = function () {

    }

    var updateCloudList = function () {
        cloudApi.getList().then(function (clouds) {
            $scope.clouds = clouds;
        });
    };

    // Get all the existing clouds and save them in the scope
    updateCloudList();

    // Set up a new cloud object to help with cloud creation
    $scope.newCloud = {};
    $scope.newTab = {};

    // Create a new cloud
    $scope.createCloud = function (cloud) {
        cloudApi.post(cloud).then(function (res) {
            updateCloudList();
        }, function (err) {
            console.log(err.status);
        });
    };

    // Update and existing cloud
    $scope.updateCloud = function (cloud) {
        cloud.put().then(function (res) {
            updateCloudList();
        });
    };

    // Delete and existing cloud
    $scope.deleteCloud = function (cloud) {
        cloud.remove().then(function (res) {
            updateCloudList();
        }, function (err) {
            console.log(err.status);
        });
    };

    // Create a new cloud
    $scope.createTab = function (tab) {


        $scope.tabs.push(angular.copy(tab));
        $scope.$apply();
        angular.element('#' + tab.name).tab('show');
        $scope.newTab = {};


    };

});
;
fooformsApp.controller('DashboardCtrl', function ($scope, $route) {
    'use strict';
});
;
fooformsApp.controller('ProfileCtrl', function ($scope, $route, Restangular) {
    'use strict';
    Restangular.setBaseUrl('/api');
    Restangular.one('user', 'me').get().then(function (user) {
        $scope.user = user;
    });

    $scope.update = function (user) {
        $scope.user = angular.copy(user);
        $scope.user.put();
    };
});